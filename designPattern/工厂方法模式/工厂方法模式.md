# 工厂方法模式 #
　　
> 定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。

工厂方法模式结构图如下：<br>
![](https://github.com/herodll/myblog/blob/master/designPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.jpg)

　　如上图所示：这里举个学雷锋例子，比如有个人A要学雷锋做好事，这个人作为一个具体的产品，就相当于是结构图中的ConcreteProduct类的对象，表示一个具体的对象，而为老人服务，老人（相当于客户端）并不需要知道这个服务对象的信息，不需要知道他叫什么等，所以该具体的类ConcreteProduct需要继承一个抽象类Product，以便封装具体的类对象，并且该类中包含雷锋所具有的各种方法；但这样还不够，雷锋工厂类作为一个抽象类，相当于上图中的Creator类，这个类就像一个生产雷锋的工厂一样，返回一个学雷锋的对象，而学雷锋的大学生工厂类就是雷锋工厂类的子类，也就是上图中的ConcreteCreator类，因为学雷锋的除了大学生，可能还有其他人，所以当需求改变，我们只需要增加一个这样的类似工厂类以及一个具体的产品ConcreteProduct类就可以了。<br>
　　在依赖关系中，如果A依赖于B，那么一般B对象会作为A类的构造函数的返回值，指生成一个B这样的对象。