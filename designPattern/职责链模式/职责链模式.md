# 职责链模式 #
　　职责链模式：
> 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。这里发出这个请求的客户端并不知道这当中的哪一个对象最终处理这个请求，这样系统的更改可以在不影响客户端的情况下动态地重新组织和分配责任。

　　职责链模式的结构图：
![](https://github.com/herodll/myblog/blob/master/designPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.jpg)

　　如上图所示：Handler类作为一个处理请示接口的抽象类，ConcreteHandler类就是具体处理的类，处理它所处理的请求，可访问它的后继者，如果可以处理该请求，就处理之，否则就将该请求转发给它的后继者。<br>
　　职责链的好处:当客户提交一个请求时，请求是沿着链传递直至有一个ConcreteHandler对象负责处理它。这样做的好处就是请求者不用管哪个对象来处理，反正该请求会被处理就对了，这就使得接收者和发送者都没有对象的明确的信息，且链中的对象自己也并不知道链的结构，结果是职责链可简化对象的相互连接，它们仅需要保持一个指向其后继者的引用，而不需要保持它所有的候选接收者的引用。降低了耦合度。并且可以随时增加或者修改处理一个请求的结构，增强了给对象指派职责的灵活性。但是一个请求极有可能到了链的末端都得不到处理，或者因为没有正确配置而得不到处理。所以必须考虑全面。
　　举个例子：我要请假，先去找部门经理，经理说他没有权利，可以问问总监，总监说他没权利，可以问问总经理，总经理处理完请假之后，我就可以走人了。所以在这个例子中，管理者可以作为Handler类（抽象类），而申请请求可以作为抽象方法。