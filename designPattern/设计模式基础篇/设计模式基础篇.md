# 设计模式基础篇 #

　**设计原则：**<br>

　　1.开闭原则　
> 开闭原则即为开放封闭原则，就是指软件实体（类，模块，函数等）应该是可以扩展的，而不可修改，即“对于扩展开放，对修改封闭”。<br>
　　

　　2.里氏代换原则
> 一个软件实体中能使用父类的地方，也一定适应子类，而且程序行为没有变化，也即子类型必须能够替换它们的父类型。<br>

　　3.依赖倒转原则
> 针对接口编程，而非实现，其包含两层含义：高层模块不应依赖低层模块，两个都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。

　　4.迪米特原则
> 又称最少知道原则，如两类不必彼此通信，那就不应发生直接的相互作用，如一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用，强调类之间的松耦合。<br>

　　5.单一职责原则
> 类似功能单一，就一个类而言，应该仅有一个引起变化的原因。<br>

　　6.合成/聚合复用原则
> 尽量使用合成和聚合，而尽量不要使用类继承。<br>

　　**类与类之间的关系：**<br>

　　1.泛化关系：也就是继承关系，用**空心三角和实线**表示<br>
　　2.关联关系：表示“知道”，“了解”，如果A需要B，那么由A指向B，用**实线和箭头** 表示<br>
　　3.聚合关系：聚合关系是一种“弱拥有”，A可以包含B,B不是A不可分割的一部分，如雁群和大雁的关系，菱形在雁群这边，实线箭头指向大雁，用**空心菱形和实线箭头**表示<br>
　　4.组合关系：组合关系是一种“强拥有”，有严格部分与整体的关系，是不可分割的一部分，如鸟和翅膀的关系，用**实心菱形和实线箭头** 表示<br>
　　5.依赖关系：表示“需要”，“离不开”，比如动物需要氧气和水，A的存在必须依赖于另一个对象B，则A依赖于B，用**虚线箭头**表示<br>
　　6.实现关系：实现接口，用**空心三角和虚线**表示<br>
![](https://github.com/herodll/myblog/blob/master/designPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%AF%87/%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg)

　**设计模式的三种类型：**<br>
　　1.创建型模式（5钟）：单例模式、抽象工厂模式、建造者模式、工厂方法模式、原型模式。<br>
　　2.结构型模式（7种）：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。<br>
　　3.行为型模式（11种）：模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。<br>
　　**创建型模式：**<br>
　　1.单例模式：保证一个类只有一个实例或者固定个数的实例，并提供一个访问它的全局访问点。<br>
　　2.抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br>
　　3.建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>
　　4.工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。<br>
　　5.原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br>
　　**结构型模式：**<br>
　　1.适配器模式：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>
　　2.桥接模式：将抽象部分与它的实现部分分离，使它们可以独立地变化。<br>
　　3.装饰模式：动态地给一个对象添加一个额外的职责，就增加功能来说，装饰模式比生成子类更加灵活。<br>
　　4.组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。<br>
　　5.外观模式：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>
　　6.享元模式：运用共享技术有效地支持大量细粒度的对象。<br>
　　7.代理模式：为其他对象提供一种代理以控制这个对象的访问。<br>
　　**行为型模式：**<br>
　　1.模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br>
　　2.命令模式：将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。<br>
　　3.迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。<br>
　　4.观察者模式：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。<br>
　　5.中介者模式：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地互相引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
　　6.备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态，这样以后可将该对象恢复到原先保存的状态。<br>
　　7.解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。<br>
　　8.状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像时改变了其类。<br>
　　9.策略模式：它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。<br>
　　10.职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。<br>
　　11.访问者模式：表示一个作用于某对象结构中的各个元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

